"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lint = require("tslint/lib");
var ts = require("typescript");
var nodeIsKind_1 = require("../helpers/nodeIsKind");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithFunction(sourceFile, walk);
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
    ts.forEachChild(ctx.sourceFile, function cb(node) {
        if (nodeIsKind_1.nodeIsKind(node, 'CallExpression') &&
            nodeIsKind_1.nodeIsKind(node.expression, 'Identifier')) {
            checkFunctionName(ctx, node.expression);
        }
        return ts.forEachChild(node, cb);
    });
}
var whitelist = ['Array', 'Boolean', 'Error', 'Function', 'Number', 'Object', 'String'];
function checkFunctionName(ctx, name) {
    var firstLetter = name.text.charAt(0);
    if (firstLetter !== firstLetter.toLowerCase() &&
        whitelist.indexOf(name.text) === -1) {
        ctx.addFailureAtNode(name, 'local function names should be camelCase');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FtZWxDYXNlTG9jYWxGdW5jdGlvbnNSdWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2FtZWxDYXNlTG9jYWxGdW5jdGlvbnNSdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlDQUFrQztBQUNsQywrQkFBZ0M7QUFDaEMsb0RBQWtEO0FBRWxEO0lBQTBCLHdCQUF1QjtJQUFqRDs7SUFJQSxDQUFDO0lBSE8sb0JBQUssR0FBWixVQUFhLFVBQXlCO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQTtJQUNoRCxDQUFDO0lBQ0YsV0FBQztBQUFELENBQUMsQUFKRCxDQUEwQixJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FJaEQ7QUFKWSxvQkFBSTtBQU1qQixTQUFTLElBQUksQ0FBQyxHQUEyQjtJQUN4QyxFQUFFLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLENBQUMsSUFBYTtRQUN4RCxJQUNDLHVCQUFVLENBQW9CLElBQUksRUFBRSxnQkFBZ0IsQ0FBQztZQUNyRCx1QkFBVSxDQUFnQixJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxFQUN2RDtZQUNELGlCQUFpQixDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUE7U0FDdkM7UUFDRCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBQ2pDLENBQUMsQ0FBQyxDQUFBO0FBQ0gsQ0FBQztBQUVELElBQU0sU0FBUyxHQUFHLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUE7QUFFekYsU0FBUyxpQkFBaUIsQ0FBQyxHQUEyQixFQUFFLElBQW1CO0lBQzFFLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBQ3ZDLElBQ0MsV0FBVyxLQUFLLFdBQVcsQ0FBQyxXQUFXLEVBQUU7UUFDekMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQ2xDO1FBQ0QsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSwwQ0FBMEMsQ0FBQyxDQUFBO0tBQ3RFO0FBQ0YsQ0FBQyJ9