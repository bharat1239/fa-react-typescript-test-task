"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Lint = require("tslint/lib");
var ts = require("typescript");
var detect_newline_1 = require("detect-newline");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        var options = {
            whitespaceInsensitive: this.getOptions().ruleArguments.indexOf('whitespace-insensitive') > -1,
        };
        return this.applyWithWalker(new Walker(sourceFile, this.ruleName, options));
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var Walker = /** @class */ (function (_super) {
    __extends(Walker, _super);
    function Walker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Walker.prototype.walk = function (sf) {
        var _this = this;
        var _loop_1 = function (importGroup) {
            var sortableLinesToImports = new Map();
            var unsortedLines = importGroup.map(function (importDeclaration) {
                // opening brace is below alphanumeric characters char-code-wise, but want named imports above defaults
                // + comes directly after *, so swap with that
                var sortableLine = importDeclaration
                    .getText(sf)
                    .toLowerCase()
                    .replace('import {', 'import +');
                if (_this.options.whitespaceInsensitive) {
                    sortableLine = _this.normalizeAllWhitespace(sortableLine);
                }
                sortableLinesToImports.set(sortableLine, importDeclaration);
                return sortableLine;
            });
            var sortedLines = unsortedLines.slice().sort(function (left, right) {
                if (_this.isSideEffectImport(sortableLinesToImports.get(left)) &&
                    _this.isSideEffectImport(sortableLinesToImports.get(right))) {
                    return 0;
                }
                return left > right ? 1 : left < right ? -1 : 0;
            });
            var _loop_2 = function (i) {
                if (unsortedLines[i] !== sortedLines[i] &&
                    !this_1.isSideEffectImport(sortableLinesToImports.get(unsortedLines[i])) &&
                    !this_1.isSideEffectImport(sortableLinesToImports.get(sortedLines[i]))) {
                    var expectedImportIndex = this_1.findIndex(unsortedLines, function (line) { return line === sortedLines[i]; });
                    var expectedImport = importGroup[expectedImportIndex];
                    var actualImport = importGroup[i];
                    var message = this_1.normalizeAllWhitespace(this_1.getFailureMessage(expectedImport, actualImport));
                    var sortedImports = sortedLines.map(function (line) {
                        return sortableLinesToImports
                            .get(line)
                            .getFullText(sf)
                            .trim();
                    });
                    var groupStart = importGroup[0].getStart(sf);
                    var groupEnd = importGroup[importGroup.length - 1].getEnd();
                    var newline = detect_newline_1.graceful(sf.getFullText());
                    var fix = Lint.Replacement.replaceFromTo(groupStart, groupEnd, sortedImports.join(newline));
                    // work around some kind of multiline error span bug in tslint rule testing
                    var failureNode = /\n/.test(actualImport.getText(sf).trim())
                        ? actualImport.getFirstToken()
                        : actualImport;
                    this_1.addFailureAtNode(failureNode, message, fix);
                    return "break";
                }
            };
            for (var i = 0; i < unsortedLines.length; i += 1) {
                var state_1 = _loop_2(i);
                if (state_1 === "break")
                    break;
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = this.getImportGroups(sf); _i < _a.length; _i++) {
            var importGroup = _a[_i];
            _loop_1(importGroup);
        }
    };
    Walker.prototype.getImportGroups = function (sourceFile) {
        var breakGroup = true;
        var importGroups = [[]];
        for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
            var statement = _a[_i];
            if (this.isImportStatement(statement)) {
                importGroups[importGroups.length - 1].push(statement);
                breakGroup = true;
            }
            else if (breakGroup) {
                importGroups.push([]);
                breakGroup = false;
            }
        }
        return importGroups.filter(function (group) { return group.length > 0; });
    };
    Walker.prototype.findIndex = function (array, predicate) {
        for (var i = 0; i < array.length; i += 1) {
            if (predicate(array[i])) {
                return i;
            }
        }
    };
    Walker.prototype.isImportStatement = function (node) {
        return (node.kind === ts.SyntaxKind.ImportDeclaration ||
            this.isImportRequireStatement(node));
    };
    Walker.prototype.getFailureMessage = function (expectedImport, actualImport) {
        var expected = this.getImportBindingName(expectedImport);
        var actual = this.getImportBindingName(actualImport);
        return "out-of-order imports: expected '" + expected + "' but saw '" + actual + "'";
    };
    Walker.prototype.getImportBindingName = function (node) {
        var sf = this.getSourceFile();
        if (this.isImportRequireStatement(node)) {
            return node.name.getText(sf);
        }
        else {
            if (node.importClause) {
                return node.importClause.getText(sf);
            }
            return node.moduleSpecifier.getText(sf);
        }
    };
    Walker.prototype.isImportRequireStatement = function (node) {
        return node.kind === ts.SyntaxKind.ImportEqualsDeclaration;
    };
    Walker.prototype.isSideEffectImport = function (node) {
        return !this.isImportRequireStatement(node) && !node.importClause;
    };
    Walker.prototype.normalizeAllWhitespace = function (content) {
        return content.replace(/[\s]+/g, ' ').replace(', }', ' }');
    };
    return Walker;
}(Lint.AbstractWalker));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydEltcG9ydHNSdWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic29ydEltcG9ydHNSdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlDQUFrQztBQUNsQywrQkFBZ0M7QUFDaEMsaURBQTBEO0FBTTFEO0lBQTBCLHdCQUF1QjtJQUFqRDs7SUFTQSxDQUFDO0lBUk8sb0JBQUssR0FBWixVQUFhLFVBQXlCO1FBQ3JDLElBQU0sT0FBTyxHQUFZO1lBQ3hCLHFCQUFxQixFQUNwQixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN2RSxDQUFBO1FBRUQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUE7SUFDNUUsQ0FBQztJQUNGLFdBQUM7QUFBRCxDQUFDLEFBVEQsQ0FBMEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBU2hEO0FBVFksb0JBQUk7QUFXakI7SUFBcUIsMEJBQTRCO0lBQWpEOztJQWlKQSxDQUFDO0lBaEpPLHFCQUFJLEdBQVgsVUFBWSxFQUFpQjtRQUE3QixpQkEyRUM7Z0NBMUVXLFdBQVc7WUFDckIsSUFBTSxzQkFBc0IsR0FBRyxJQUFJLEdBQUcsRUFBZ0MsQ0FBQTtZQUN0RSxJQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLFVBQUEsaUJBQWlCO2dCQUN0RCx1R0FBdUc7Z0JBQ3ZHLDhDQUE4QztnQkFDOUMsSUFBSSxZQUFZLEdBQUcsaUJBQWlCO3FCQUNsQyxPQUFPLENBQUMsRUFBRSxDQUFDO3FCQUNYLFdBQVcsRUFBRTtxQkFDYixPQUFPLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFBO2dCQUVqQyxJQUFJLEtBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLEVB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