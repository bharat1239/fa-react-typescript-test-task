"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var lib_1 = require("tslint/lib");
var typescript_1 = require("typescript");
var cachedStat_1 = require("./utils/cachedStat");
var Rule = (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new ImportBarrelsWalker(sourceFile, this.getOptions()));
    };
    return Rule;
}(lib_1.Rules.AbstractRule));
Rule.metadata = {
    ruleName: 'import-barrels',
    description: (_a = ["\n      Enforces usage of barrels (`index.ts`) when importing from a directory that has a barrel file."], _a.raw = ["\n      Enforces usage of barrels (\\`index.ts\\`) when importing from a directory that has a barrel file."], lib_1.Utils.dedent(_a)),
    rationale: (_b = ["\n      Allows directories that contain multiple modules to be handled as a single module with a single public interface\n      and opaque inner structure.\n\n      This rule works only for ES2015 module syntax `import` statements and checks only **relative** module paths."], _b.raw = ["\n      Allows directories that contain multiple modules to be handled as a single module with a single public interface\n      and opaque inner structure.\n\n      This rule works only for ES2015 module syntax \\`import\\` statements and checks only **relative** module paths."], lib_1.Utils.dedent(_b)),
    optionsDescription: (_c = ["\n      An argument object may be optionally provided, with the following properties:\n\n      * `noExplicitBarrels = false`: disallows usage of explicitly named barrels in import statements (`import foo from './foo/index'`)\n      * `fileExtensions = ['ts', 'js']`: uses the provided file extensions for module and barrel file lookup\n      * `fixWithExplicitBarrelImport`: uses the provided string to replace non-barrel imports in `--fix` mode\n        (i.e. when set to `'index'`, `import foo from './foo/some-module'` becomes `import foo from './foo/index'`)"], _c.raw = ["\n      An argument object may be optionally provided, with the following properties:\n\n      * \\`noExplicitBarrels = false\\`: disallows usage of explicitly named barrels in import statements (\\`import foo from './foo/index'\\`)\n      * \\`fileExtensions = ['ts', 'js']\\`: uses the provided file extensions for module and barrel file lookup\n      * \\`fixWithExplicitBarrelImport\\`: uses the provided string to replace non-barrel imports in \\`--fix\\` mode\n        (i.e. when set to \\`'index'\\`, \\`import foo from './foo/some-module'\\` becomes \\`import foo from './foo/index'\\`)"], lib_1.Utils.dedent(_c)),
    optionExamples: ['[true, {"noExplicitBarrels": false, "fileExtensions": ["ts", "js"]}]'],
    options: {
        type: 'array',
        items: {
            type: 'object',
            properties: {
                noExplicitBarrels: {
                    type: 'boolean',
                },
                fileExtensions: {
                    type: 'array',
                    items: {
                        type: 'string',
                    },
                    minLength: 1,
                },
                fixWithExplicitBarrelImport: {
                    type: 'string',
                },
            },
        },
        minLength: 1,
        maxLength: 1,
    },
    type: 'maintainability',
    typescriptOnly: false,
};
Rule.USE_BARREL_FAILURE_STRING = 'Use barrel (index) files for imports if they are available for path: ';
Rule.NO_EXPLICIT_BARRELS_FAILURE_STRING = "Don't import barrel files by name, import containing directory instead for path: ";
Rule.DEFAULT_OPTIONS = {
    fileExtensions: ['ts', 'js'],
    noExplicitBarrels: false,
    fixWithExplicitBarrelImport: ''
};
exports.Rule = Rule;
var CheckResult;
(function (CheckResult) {
    CheckResult[CheckResult["OK"] = 0] = "OK";
    CheckResult[CheckResult["ExplicitBarrelsForbidden"] = 1] = "ExplicitBarrelsForbidden";
    CheckResult[CheckResult["NonBarrelImport"] = 2] = "NonBarrelImport";
})(CheckResult || (CheckResult = {}));
var ImportBarrelsWalker = (function (_super) {
    __extends(ImportBarrelsWalker, _super);
    function ImportBarrelsWalker(sourceFile, options) {
        var _this = _super.call(this, sourceFile, options) || this;
        _this.cachedStat = new cachedStat_1.CachedStat();
        _this.ruleOptions = Object.assign({}, Rule.DEFAULT_OPTIONS, _this.getOptions()[0] || {});
        return _this;
    }
    ImportBarrelsWalker.prototype.visitImportDeclaration = function (node) {
        var moduleExpression = node.moduleSpecifier;
        var expressionCheckResult = this.checkModuleExpression(moduleExpression);
        if (expressionCheckResult !== CheckResult.OK) {
            this.addFailureAtNode(moduleExpression, ImportBarrelsWalker.resultErrorMap[expressionCheckResult] + moduleExpression.getText(), this.getFix(moduleExpression, expressionCheckResult));
        }
        _super.prototype.visitImportDeclaration.call(this, node);
    };
    ImportBarrelsWalker.prototype.checkModuleExpression = function (expression) {
        var _this = this;
        if (expression.kind !== typescript_1.SyntaxKind.StringLiteral) {
            return CheckResult.OK;
        }
        var modulePathText = expression.text;
        // check only relative paths
        if (!modulePathText.startsWith('.')) {
            return CheckResult.OK;
        }
        var sourceFileRelative = this.getSourceFile().fileName;
        var sourceFileDirAbsolute = path.resolve(path.dirname(sourceFileRelative));
        var moduleAbsolute = path.normalize(path.resolve(sourceFileDirAbsolute, modulePathText));
        var moduleDirAbsolute = path.dirname(moduleAbsolute);
        // enforce barrel usage only on files that are not in the same directory or in one of the sub-directories
        // of the module
        if (sourceFileDirAbsolute.startsWith(moduleDirAbsolute)) {
            return CheckResult.OK;
        }
        var moduleStats = this.getModuleStats(moduleAbsolute);
        // only file imports are of interest
        if (!moduleStats || moduleStats.isDirectory()) {
            return CheckResult.OK;
        }
        // if module's name is 'index', it must be an explicit barrel import, dirs were excluded earlier
        if (path.parse(moduleAbsolute).name === 'index') {
            return this.ruleOptions.noExplicitBarrels ? CheckResult.ExplicitBarrelsForbidden : CheckResult.OK;
        }
        var dirHasBarrelFile = this.ruleOptions.fileExtensions
            .map(function (ext) { return path.join(moduleDirAbsolute, "index." + ext); })
            .some(function (file) { return _this.cachedStat.isFile(file); });
        return dirHasBarrelFile ? CheckResult.NonBarrelImport : CheckResult.OK;
    };
    ImportBarrelsWalker.prototype.getModuleStats = function (modulePath) {
        var _this = this;
        var modulePathCandidates = [modulePath].concat(this.ruleOptions.fileExtensions.map(function (suffix) { return modulePath + "." + suffix; }));
        var stats = null;
        modulePathCandidates.some(function (modulePathCandidate) {
            stats = _this.cachedStat.statSync(modulePathCandidate);
            return stats !== null;
        });
        return stats;
    };
    ImportBarrelsWalker.prototype.getFix = function (moduleSpecifier, checkResult) {
        var replacement = path.dirname(moduleSpecifier.text);
        if (checkResult === CheckResult.NonBarrelImport && this.ruleOptions.fixWithExplicitBarrelImport) {
            replacement += "/" + this.ruleOptions.fixWithExplicitBarrelImport;
        }
        // account for quotes
        return new lib_1.Replacement(moduleSpecifier.getStart() + 1, moduleSpecifier.getWidth() - "''".length, replacement);
    };
    return ImportBarrelsWalker;
}(lib_1.RuleWalker));
ImportBarrelsWalker.resultErrorMap = (_d = {},
    _d[CheckResult.NonBarrelImport] = Rule.USE_BARREL_FAILURE_STRING,
    _d[CheckResult.ExplicitBarrelsForbidden] = Rule.NO_EXPLICIT_BARRELS_FAILURE_STRING,
    _d);
var _a, _b, _c, _d;
//# sourceMappingURL=importBarrelsRule.js.map